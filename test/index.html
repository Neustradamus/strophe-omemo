<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="../js/libs/strophejs/strophe.js"></script>
    <script type="text/javascript" src="../js/libs/libsignaljs/dist/libsignal-protocol.js"></script>
    <script type="text/javascript" src="../js/libs/jquery-3.2.1.min.js"></script>

    <script type="text/javascript" src="../js/libsignalstore.js"></script>

    <script type="text/javascript" src="../dist/co-strophe.omemo.object.js"></script>
    <script type="text/javascript" src="../dist/co-codec.js"></script>
    <script type="text/javascript" src="../dist/co-gcm.js"></script>

    <style>
.pass:before {
  content: 'PASS: ';
  color:  blue;
  font-weight: bold;
}

    .fail:before {
      content: 'FAIL: ';
      color: red;
      font-weight: bold;

    }
    </style>
  </head>
  <body>

    <ul id="output"></ul>
    <script>
var output = document.getElementById('output');

function assert( outcome, description ) {
  var li = document.createElement('li');
  li.className = outcome ? 'pass' : 'fail';
  li.appendChild( document.createTextNode( description ) );

  output.appendChild(li);
};
    </script>
  </body>
  <script>

//**
//tests start here.
//**

function add(num1, num2) {
  return num1 + num2;
}

var result = add(2, 2);

assert( result == 4, 'Checking the add function');
assert( result == 8, 'Checking the add function');

function pprint(s){
  console.log('index.html: ' + s)
}

let aliceStore = new SignalProtocolStore()
let bobStore = new SignalProtocolStore()

let libsig = libsignal
let util = new Omemo('dummy@util.com', 000, Object, Object)
let gcm = util._gcm

let am1 = "hello dear bob"
let am2 = "hello dear alice"
let bm1 = "it's been a while."
let bm2 = "it sure has my dear."

let aliceFirstMsg = ''
let aliceSecondMsg = ''
let bobFirstMsg = '' 
let bobSecondMsg = ''

let aliceFirstKey = ''
let aliceSecondKey = ''
let bobFirstKey = ''
let bobSecondKey = ''

gcm.encrypt(am1).then(res => 
  {
    aliceFirstMsg = res
    gcm.serializeKey(res.key).then(res => {
      aliceFirstKey = res
      pprint('first alice message key: ' + res) 
    })
  })
gcm.encrypt(am2).then(res => 
  {
    aliceSecondMsg = res
    gcm.serializeKey(res.key).then(res => {
      aliceSecondKey = res
      pprint('second alice message key: ' + res) 
    })
  })
gcm.encrypt(bm1).then(res => 
  {
    bobFirstMsg = res
    gcm.serializeKey(res.key).then(res => {
      bobFirstKey = res
      pprint('first bob message key: ' + res) 
    })
  })
gcm.encrypt(bm2).then(res => 
  {
    bobSecondMsg = res
    gcm.serializeKey(res.key).then(res => {
      bobSecondKey = res
      pprint('second bob message key: ' + res) 
    })
  })

let alice = new Omemo('alice@jiddy.jid', 123, libsig, aliceStore)
let bob = new Omemo('bob@jiddy.jid', 321, libsig, bobStore)

alice.init(alice) //inner alice is context of this, could forgo, but just in case.
bob.init(bob) //inner alice is context of this, could forgo, but just in case.

//work for later - turn the code into proper Promise based so things can be 
//chained in the proper order. otherwise BobsPublicBundle tries to finish while
//arming is not done, cause the tab to hang due to store Promises not resolving.

function manualAliceSessionStart() {
  let bobsPublicBundle= bob._store.getPublicBundle(bob)
  console.log(bobsPublicBundle)
  return alice.buildSession(bobsPublicBundle, bob._jid, alice)
}

let am1enc = ''
function manualAliceLibSigEncrypt(session) {
  return session.SessionCipher.encrypt(aliceFirstKey).then(res => { 
    am1enc = res
    pprint('result saved in am1enc')
  })
}

function manualBobSession() {
  let bobsPublicBundle= bob._store.getPublicBundle(bob)
  console.log(bobsPublicBundle)
  return alice.buildSession(bobsPublicBundle, bob._jid, alice)
}

let am1dec = ''
function manualBobLibSigDecryptPreKeyMessage() {
  let bobSessionCipher = new libsigna.SessionCipher(bob._store, alice._address)
  bobSessionCipher.decryptPreKeyWhisperMessage(am1enc.body, 'binary').then(res => console.log(res))
  //should output the gcm key for am1
  //signed key issue again.

}

//have to be careful here. can only get the SessionBuilderBundle after the promise based functions above actually resolve.
//  let AliceSessionWithBob = omemo.buildSession(bobLibStore, bobLibStore.store.jid)
//  let AliceCipher = AliceSessionWithBob.SessionCipher
//
//  let msg = "hello world"
//  let encrypted = ''
//  let libSignalPayload = ''
//  let libSignalEncrypted = ''
//  let serializedKey = ''
//
//
//  omemo._gcm.encrypt(msg).then(out => {
//    encrypted = out //can get rid of this now or keep for tracking
//    gcm.serializeKey(out.key).then(res => {
//      serializedKey = res // can get rid of this now or keep for tracking
//      libSignalPayload = res // + codec.BufferToString(encrypted.tag) // having some encoding and decoding issues here
//      //need some time to look at javascript encoding functions and string byte sequence constructions.
//    })
//  })
//
//  AliceCipher.encrypt(libSignalPayload).then(res => libSignalEncrypted = res)
//
//  function buildBobCipher(jid) {
//
//    let aliceAddress = omemo._address //omemo._jid = alice@jiddy.jid, current setup 
//    let bobSerializedBundle = omemo.getSerialized("bob@jiddy.jid")
//    let bobBundle = omemo.restore(bobSerializedBundle)
//    let bobAddress = new libsignal.SignalProtocolAddress(bobBundle.store.jid, bobBundle.store.sid)
//    //missing builder 
//    let bobSessionCipher = new libsignal.SessionCipher(bobBundle, aliceAddress)
//
//    return bobSessionCipher
//
//  }
//
//  let BobCipher = buildBobCipher("bob@jiddy.jid")
//} else {
//
//}


  </script>
</html>

