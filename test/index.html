<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="../js/libs/strophejs/strophe.js"></script>
    <script type="text/javascript" src="../js/libs/libsignaljs/dist/libsignal-protocol.js"></script>
    <script type="text/javascript" src="../js/libsignalstore.js"></script>

    <script type="text/javascript" src="../dist/co-strophe.omemo.object.js"></script>

    <style>
.pass:before {
  content: 'PASS: ';
  color:  blue;
  font-weight: bold;
}

    .fail:before {
      content: 'FAIL: ';
      color: red;
      font-weight: bold;

    }
    </style>
  </head>
  <body>

    <ul id="output"></ul>
    <script>
var output = document.getElementById('output');

function assert( outcome, description ) {
  var li = document.createElement('li');
  li.className = outcome ? 'pass' : 'fail'; li.appendChild( document.createTextNode( description ) );

  output.appendChild(li);
};
    </script>
  </body>
  <script>

//**
//tests start here.
//**

function add(num1, num2) {
  return num1 + num2;
}

let result = add(2, 2);

assert( result == 4, 'Checking the add function');
assert( result == 8, 'Checking the add function');

function pprint(s){
  console.log('index.html: ' + s)
}

/*

before asserts/tests can be sanely implemented, the main file has be to 
rewritten in Promise format.

store/gcm/codec asserts on types can be safely implemented beforehand.

 */


//store function return type asserts here


//bundle creation asserts here


//inner omemo object instantiation asserts here


//codec asserts here


//gcm asserts here


//session asserts here


//initial msg assersts here


//non prekey message asserts here


let aliceStore = new SignalProtocolStore()
let bobStore = new SignalProtocolStore()

let libsig = libsignal
let util = new Omemo('dummy@util.com', 000, Object, Object)
let gcm = util._gcm

let msgs = [
  "2:pong!",
  "3:ping!",
  "4:pong!",
  "5:ping!"
]

let one_sided = [
  "1:first",
  "2:second repeat",
  "3:third repeat"
]

let aliceFirstMsg = ''
let aliceSecondMsg = ''
let bobFirstMsg = '' 
let bobSecondMsg = ''

let aliceFirstKey = ''
let aliceSecondKey = ''
let bobFirstKey = ''
let bobSecondKey = ''

let am1 = "hello bob"
let am2 = "hello alice"
let bm1 = "hows things"
let bm2 = "good good"
let bm3 = "what are you upto to two"
let am3 = "writing tests for a project"

gcm.encrypt(am1).then(res => 
  {
    console.log(res)
    aliceFirstMsg = res.OMMSG
    aliceFirstKey = res.LSPLD
    pprint('first alice message key: ' + aliceFirstKey) 
  })

gcm.encrypt(am2).then(res => 
  {
    console.log(res)
    aliceSecondMsg = res.OMMSG
    aliceSecondKey = res.LSPLD
    pprint('second alice message key: ' + aliceSecondKey) 
  })
gcm.encrypt(bm1).then(res => 
  {
    console.log(res)
    bobFirstMsg = res.OMMSG
    bobFirstKey = res.LSPLD
    pprint('first bob message key: ' + bobFirstKey) 
  })
gcm.encrypt(bm2).then(res => 
  {
    console.log(res)
    bobSecondMsg = res.OMMSG
    bobSecondKey = res.LSPLD
    pprint('second bob message key: ' + bobSecondKey) 
  })

let alice = new Omemo('alice@jiddy.jid', 123, libsig, aliceStore)
let bob = new Omemo('bob@jiddy.jid', 321, libsig, bobStore)

alice.init(alice) //inner alice is context of this, could forgo, but just in case.
bob.init(bob) //inner alice is context of this, could forgo, but just in case.

//work for later - turn the code into proper Promise based so things can be 
//chained in the proper order. otherwise BobsPublicBundle tries to finish while
//arming is not done, cause the tab to hang due to store Promises not resolving.

let aliceSessionCipher, bobSessionCipher
//alice estbalishes session
function start() {
  return bob._store.getPublicBundle(bob).then(res =>  {
    return  alice.buildSession(res, bob._jid, alice).then(res =>  {
      aliceSessionCipher = res.SessionCipher
      doenc(aliceSessionCipher)
    })
  })
}

let am1enc = ''
//alice encrypts her first message with the session, gets called in one.
function doenc() {
  return aliceSessionCipher.encrypt(aliceFirstKey).then(res => { 
    am1enc = res
    pprint('result saved in am1enc')
  })
}

let am1dec = ''
//bob receives alice's first message, decrypts it as a prekey whisper message
function two() {
  bobSessionCipher = new libsignal.SessionCipher(bob._store, alice._address)
  bobSessionCipher.decryptPreKeyWhisperMessage(am1enc.body, 'binary').then(res => {
    let decoder = new TextDecoder()
    pprint("initial session with alice complete - preKeyWhisperMessage success.\nResult saved in am1dec")
    return Promise.resolve(am1dec = decoder.decode(res))
  })
}

//bob moves on to decrypt the output of step three, which is a decrypted gcm key 
let firstMsgEndResult
function three() {
  let decoder = new TextDecoder()
  return gcm.decrypt(am1dec, aliceFirstMsg.cipherText, aliceFirstMsg.iv, aliceFirstMsg.aad).then(res => {
    firstMsgEndResult = res
    pprint("alice said: " + res)
    return res
  }) 
}

//alice and bob exchange messages, 
//bob replies and the exchange starts.
function four() {
  //assumes steps 1-3 were executed and 
  //a session between both is established
  let key1, key2, skip_key3, key4, key5, ready
  let arrStr =  [
    "hello bob"
    ,"hello alice"
    ,"hows things"
    ,"good good"
    ,"what are you upto to two"
    ,"writing tests for a project"
  ]

  console.log(arrStr)
  var arrKs = [] 
  for (var i in arrStr) {
    gcm.encrypt(arrStr[i]).then(res=> {
      arrKs[i] =  res.k
    })
  }
}


//alice sends messages in a chain without bob replying, bob receives and decrypts

  </script>
</html>

